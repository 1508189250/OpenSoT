/*
 * Copyright: (C) 2014 Walkman Consortium
 * Authors: Alessio Rocchi
 * CopyPolicy: Released under the terms of the GNU GPL v2.0.
*/


#include "sot_VelKinCon_constants.h"
#include <string>
#include <math.h>
#include <assert.h>

/** creates a yarpscope xml file starting from ParamProxyInterface array */
const std::string createMonitorScope(const ParamProxyInterface *const sot_VelKinCon_ParamDescr[], unsigned int size, std::string moduleName);
/** gets the starting index in monitor:o of a parameter specified by id*/
const int getStartingPlotIndexById(const ParamProxyInterface *const sot_VelKinCon_ParamDescr[], unsigned int size, unsigned int id);

int main(int argc, char* argv[]) {
    std::string moduleName = std::string("sot_VelKinCon_DEBUG");
    const std::string scopeXml = createMonitorScope(wb_sot::sot_VelKinCon_ParamDescr,
                                                    wb_sot::PARAM_ID_SIZE,
                                                    moduleName);
    std::cout << scopeXml;
    return 0;
}

/** takes an array of ParamProxies, creates a scope for them
    TODO move this to a proper place
    TODO make this somehow automatic (e.g. a program using paramHelp
         will be automatically be able to create the monitor scope when calling
         paramHelp with a script, or maybe with some util?*/
const std::string createMonitorScope(const ParamProxyInterface *const sot_VelKinCon_ParamDescr[],
                                     unsigned int size,
                                     std::string moduleName) {
    std::stringstream ss;
    unsigned int nrows;
    unsigned int ncols;


    ncols = ceil(sqrt(size));
    nrows = floor(size/ncols);

    ss << "<!--" << std::endl;
    ss << "Scope for the monitor port of module " << moduleName << std::endl;
    ss << "Author: automatically generated by createMonitorScope" << std::endl;
    ss << "This xml file must be used with yarpscope: it plots by columns the joint commands for the legs. -->" << std::endl;

    ss << "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" << std::endl;
    ss << "<portscope rows=\"" << nrows << "\"" <<
                    " columns=\"" << ncols << "\" carrier=\"udp\" persistent=\"1\">" << std::endl;
    unsigned int gridx = 0;
    unsigned int gridy = 0;
    for(unsigned int i = 0; i < size; ++i) {
        const ParamProxyInterface *proxy = sot_VelKinCon_ParamDescr[i];
        if(proxy->ioType.isMonitoring()) {
            unsigned int startingPlotIndex = getStartingPlotIndexById(sot_VelKinCon_ParamDescr, size,
                                                                      proxy->id);
            ss <<"     <plot gridx=\"" << gridx << "\"" << std::endl <<
                 "           gridy=\"" << gridy << "\"" << std::endl <<
                 "           hspan=\"1\"" << std::endl <<
                 "           vspan=\"1\"" << std::endl <<
                 /** would be nice to have a way to check constraints */
                 "           title=\"" << proxy->name << " - "
                                       << proxy->description << "\"" << std::endl <<
                 "           bgcolor=\"White\">" << std::endl;
            for(unsigned int j = 0; j < proxy->size; ++j) {
                ss <<"         <graph remote=\"/" << moduleName << "/monitor:o\"" << std::endl <<
                     "                index=\""<< (startingPlotIndex + j) <<"\"" << std::endl <<
                     /** @TODO we currently have no way to change color. It will be automatically done by plot? */
                     /* "                color=\"Blue\"" << std::endl << */
                     "                type=\"lines\"" << std::endl <<
                     "                size=\"2\" />" << std::endl;
            }

            gridy = (gridy + 1)%ncols;
            if(gridy == 0)
                gridx++;

            ss << "     </plot>" << std::endl;
        }
    }
    ss << "</portscope>" << std::endl;
    ss.sync();
    return ss.str();
}

const int getStartingPlotIndexById(const ParamProxyInterface *const sot_VelKinCon_ParamDescr[], unsigned int size, unsigned int id) {
    assert(id >= 0);
    int startingIndex = 0;
    for(unsigned int i; i < size; ++i) {
        const ParamProxyInterface *proxy = sot_VelKinCon_ParamDescr[i];
        if(proxy->ioType.isMonitoring() && proxy->id < id) {
            assert(proxy->size >= 0);
            startingIndex += proxy->size;
        }
    }
    return startingIndex;
}
